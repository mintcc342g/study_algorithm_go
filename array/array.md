# Array
## 목차
- [Searching](#searching)
  - [Binary Search](#binary-search)
- [Sorting](#sorting)
  - [Bubble Sort](#bubble-sort)
  - [Selection Sort](#selection-sort)
  - [Insertion Sort](#insertion-sort)
  - [Quick Sort](#quick-sort)
  - [Quick Select](#quick-select)


## 관련 알고리즘

### Searching

#### Binary Search
- 이진 탐색은 전체 데이터를 절반씩 나누면서 검색하는 방법
    - 예를 들어, 1~100 의 숫자 중 3 을 찾는다고 해보자.
    - 우선 1~100의 중간값인 50을 뽑고,
    - 3이 50보다 크다면 범위를 51~100 으로 잡음,
    - 3이 50보다 작다면 범위를 1~50 으로 잡음.
    - 위의 과정을 반복 (passthrough)
- 범위를 절반씩 좁혀가기 때문에 O(log N)의 효율을 가짐.

### Sorting

#### Bubble Sort
- 배열 내 연속된 두 항목을 비교하며 정렬하는 방식
- 비교하는 2개의 항목 중 가장 큰 값(=버블)을 순서에 맞는 위치로 옮기기 때문에 버블 정렬이라고 함.
- 비교 후 스와프까지 하기 때문에 한 passthrough 당 2단계가 걸림.
- 그래서 효율성은 O(N^2) 임.

#### Selection Sort
- 배열의 각 셀을 돌며 셀의 값과 최소값을 비교하며 정렬하는 방식
    - 예를 들어, 시작은 0번째 인덱스부터 하고 최소값 설정도 0번 인덱스의 값부터.
    - 1번 인덱스의 값고 0번째를 비교
    - 1번 인덱스 값이 더 크면 0번 인덱스 값을 최소값으로 유지
    - 0번 인덱스 값이 더 크면 1번 인덱스 값을 최소값으로 변경
    - 위 과정을 반복
- 선택 정렬은 모든 시나리오에서 O(N^2) 효율을 가짐.

#### Insertion Sort
- 최소값과 현재 배열의 값을 비교한 후, 최소값을 배열에 밀어넣으며 정렬을 하는 방식
    - 시작할 때는 1번 인덱스의 값을 최소값으로 설정한 후 시작
    - 최소값과 모든 배열의 값을 비교함.
    - 만약 현재 배열의 값이 최소값보다 더 크다면, 현재 배열의 위치에 최소값을 넣어줌.
    - 그리고 현재 배열의 값을 최소값 자리로 옮김.
    - 이상을 반복
- 삽입 정렬의 효율은 시나리오에 따라 많이 달라짐.
    - 최악 : N^2 단계
    - 평균 : N^2 / 2 단계
    - 최선 : N 단계

#### Quick Sort
- Divide-and-Conquer 방법을 사용하는 대표적인 알고리즘 중 하나
- 구현 방법: 오름차순
    - 분할 단계
        - 배열의 맨 마지막 값을 피벗으로 설정
        - 피벗 위치는 제외하고 배열의 맨 앞과 맨 뒤 값에 포인터 설정함.
        - 왼쪽 포인터는 피벗보다 큰 수가 나오기 전까지 계속 오른쪽으로 움직여줌.
        - 오른쪽 포인터는 피벗보다 작은 수가 나오기 전까지 계속 왼쪽으로 움직여줌.
        - 포인터 둘 다 멈췄을 때, 두 포인터가 가리키는 값을 서로 바꿔줌.
        - 위 과정을 반복
        - 반복하다가 두 포인터가 같은 값을 가리키거나 포인터가 서로 교차됐을 때 왼쪽 포인터가 가리키는 값과 피벗 값을 바꿔줌.
            - 이러면 피벗을 기준으로 왼쪽 값은 전부 피벗보다 작은 값, 오른쪽 값은 피벗보다 큰 값들로 이루어지게 됨.
        - 왼쪽 포인터가 사실상 피벗값을 가리키게 됐음.
    - 정렬 단계
        - 피벗값을 기준으로 왼쪽 배열에 대해 분할 단계를 재귀적으로 반복함.
        - 피벗값을 기준으로 오른쪽 배열에 대해 분할 단계를 재귀적으로 반복함.
        - 재귀 종료 조건은(기저 조건) 배열의 원소가 1개 이하가 됐을 때임.
- 내림차순 일 땐 왼쪽 <-> 오른쪽 하면 됨.
- 효율
    - 분할하는 횟수가 평균적으로 N * log N 이라서 O(N log N) 이라는 듯

#### Quick Select
- 퀵 정렬(Qick Sort)을 이용한 탐색 알고리즘 중 하나
- 여러 값이 주어졌을 때 k번째로 작은/큰 값을 찾을 때 유용함.
- 구현 방법
    - k번째로 작은 수를 찾을 때: 오름차순
        - 분할 단계
            - 퀵 정렬 오름차순 일 때랑 동일함.
        - 탐색 단계
            - 찾고자 하는 값이 피벗 기준 왼쪽이라면 왼쪽 배열만 재귀로 검색함.
            - 찾고자 하는 값이 피벗 기준 오른쪽이라면 오른쪽 배열만 재귀로 검색함.
    - k번째로 큰 수를 찾을 때: 내림차순으로 해주면 됨.
- 효율
    - 퀵 정렬에서 하는 전체 배열의 정렬 과정을 거치지 않기 때문에 O(N) 의 효율을 가진다고 함.