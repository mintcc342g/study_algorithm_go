# Array

## Searching

- 이진 검색
    - 이진 검색은 전체 데이터를 절반씩 나누면서 검색하는 방법
       - 예를 들어, 1~100 의 숫자 중 3 을 찾는다고 해보자.
        - 우선 1~100의 중간값인 50을 뽑고,
        - 3이 50보다 크다면 범위를 51~100 으로 잡음,
        - 3이 50보다 작다면 범위를 1~50 으로 잡음.
        - 위의 과정을 반복 (passthrough)
    - 범위를 절반씩 좁혀가기 때문에 O(log N)의 효율을 가짐.

<br/>

## Sorting

- 버블 정렬
    - 배열 내 연속된 두 항목을 비교하며 정렬하는 방식
    - 비교하는 2개의 항목 중 가장 큰 값(=버블)을 순서에 맞는 위치로 옮기기 때문에 버블 정렬이라고 함.
    - 비교 후 스와프까지 하기 때문에 한 passthrough 당 2단계가 걸림.
    - 그래서 효율성은 O(N^2) 임.

<br/>

- 선택 정렬
    - 배열의 각 셀을 돌며 셀의 값과 최소값을 비교하며 정렬하는 방식
        - 예를 들어, 시작은 0번째 인덱스부터 하고 최소값 설정도 0번 인덱스의 값부터.
        - 1번 인덱스의 값고 0번째를 비교
        - 1번 인덱스 값이 더 크면 0번 인덱스 값을 최소값으로 유지
        - 0번 인덱스 값이 더 크면 1번 인덱스 값을 최소값으로 변경
        - 위 과정을 반복
- 선택 정렬은 모든 시나리오에서 O(N^2) 효율을 가짐.

<br/>

- 삽입 정렬
    - 최소값과 현재 배열의 값을 비교한 후, 최소값을 배열에 밀어넣으며 정렬을 하는 방식
        - 시작할 때는 1번 인덱스의 값을 최소값으로 설정한 후 시작
        - 최소값과 모든 배열의 값을 비교함.
        - 만약 현재 배열의 값이 최소값보다 더 크다면, 현재 배열의 위치에 최소값을 넣어줌.
        - 그리고 현재 배열의 값을 최소값 자리로 옮김.
        - 이상을 반복
    - 삽입 정렬의 효율은 시나리오에 따라 많이 달라짐.
        - 최악 : N^2 단계
        - 평균 : N^2 / 2 단계
        - 최선 : N 단계

<br/>

- 퀵 정렬
    - Divide-and-Conquer 방법을 사용하는 대표적인 알고리즘 중 하나
    - 구현 방법
        - 1단계: 피벗 기준 정렬
            - 배열의 맨 마지막 값을 피벗으로 설정
            - 피벗을 제외하고 배열의 맨 앞과 맨 뒤 값에 포인터 설정함.
            - 왼쪽 포인터는 피벗보다 큰 수가 나오기 전까지 계속 오른쪽으로 움직여줌.
            - 오른쪽 포인터는 피벗보다 작은 수가 나오기 전까지 계속 왼쪽으로 움직여줌.
            - 포인터 둘 다 멈췄을 때, 해당 포인터들이 가리키는 값을 서로 바꿔줌.
            - 두 포인터가 같은 값을 가리키기 전까지 이 과정을 반복
            - 두 포인터가 같은 값을 가리켰을 때, 피벗과 그 값을 서로 바꿔줌.
            - 이러면 피벗을 기준으로 왼쪽 값은 전부 피벗보다 작은 값, 오른쪽 값은 피벗보다 큰 값들로 이루어지게 됨.
        - 2단계: 분할
            - 여기서 피벗을 기준으로 배열을 분할
            - 하위 배열들을 각각 1~2단계를 반복시키면서 계속 분할시킴.
        - 3단계: 종료
            - 각 하위 배열들에서 왼쪽 포인터가 오른쪽 포인터를 지나치게 됐을 때 정렬을 끝냄.
            - 모든 하위 배열에서 멈추게 됐을 때 퀵 정렬의 종료
    - 효율
        - 분할하는 횟수가 평균적으로 N * log N 이라서 O(N log N) 이라는 듯

<br/>

- 퀵 셀렉트
    - 퀵 정렬을 이용한 검색 알고리즘 중 하나
    - 퀵 정렬에서 하는 전체 배열의 정렬 과정을 거치지 않기 때문에 O(N) 의 효율을 가진다고 함.