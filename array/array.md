# Array
## 목차
- [Searching](#searching)
  - [Binary Search](#binary-search)
  - [Quick Select](#quick-select)
- [Sorting](#sorting)
  - [Bubble Sort](#bubble-sort)
  - [Selection Sort](#selection-sort)
  - [Insertion Sort](#insertion-sort)
  - [Quick Sort](#quick-sort)
  - [Merge Sort](#merge-sort)

## 관련 알고리즘

### Searching

#### Binary Search
- 이진 탐색은 전체 데이터를 절반씩 나누면서 검색하는 방법
    - 예를 들어, 1~100 의 숫자 중 3 을 찾는다고 해보자.
    - 우선 1 ~ 100의 중간값인 50을 뽑음.
    - 3이 50보다 크다면 범위를 51 ~ 100 으로 다시 잡음.
    - 3이 50보다 작다면 범위를 1 ~ 49 으로 다시 잡음.
    - 같다면 발견한 것
    - 위의 과정(passthrough)을 반복함.
- 배열에서 중간값 구할 때 인덱스는 `left + (right-left)/2` 로 구하는 게 좋음.
    - `(right+left)/2`와 같지만, 이 경우 배열이 너무 큰 수가 나오면 오버플로우가 발생함.
- 2차원 배열에서 중간값을 구할 경우엔 다음의 공식을 사용해야 함.
    - 왼쪽 초기값: `0`
    - 오른쪽 초기값: `len(outer)*len(inner) - 1`
    - 중간 인덱스: `left + (right - left)/2`
    - 중간 인덱스의 값: `arr[mid_idx/len(inner)][mid_idx%len(inner)]`    
    - 조건 충족 여부에 따라서 `mid - 1`, `mid + 1` 하는 건 같음.
- 효율
    - O(log N)
    - 범위를 절반씩 좁혀가기 때문에

#### Quick Select
- [퀵 정렬(Qick Sort)](#quick-sort)을 이용한 탐색 알고리즘 중 하나
- 여러 값이 주어졌을 때 k번째로 작은/큰 값을 찾을 때 유용함.
- 구현 방법
    - k번째로 작은 수를 찾을 때: 오름차순
        - 분할 단계
            - [퀵 정렬](#quick-sort) 오름차순 일 때랑 동일함.
        - 탐색 단계
            - 찾고자 하는 값이 피벗 기준 왼쪽이라면 왼쪽 배열만 재귀로 검색함.
            - 찾고자 하는 값이 피벗 기준 오른쪽이라면 오른쪽 배열만 재귀로 검색함.
    - k번째로 큰 수를 찾을 때: 내림차순으로 해주면 됨.
- 시간 복잡도
    - 평균: O(N)
        - 퀵 정렬에서 하는 전체 배열의 정렬 과정을 거치지 않기 때문임.
    - 최악: O(N^2)
        - 피벗이 매 paththrough마다 배열의 가장 큰/작은 값이 선택될 경우임.
        - 이런 경우, 배열이 한 쪽으로만 분할이 되어서 모든 수와 비교하게 됨.
- 공간 복잡도
    - O(1)
- 중앙값 계산, 상위 또는 하위 k개 요소 찾기(근데 이건 heap sort가 더 좋을 수 있음..)


### Sorting

#### Bubble Sort
- 배열 내 연속된 두 항목을 비교하며 정렬하는 방식
- 비교하는 2개의 항목 중 가장 큰 값(=버블)을 순서에 맞는 위치로 옮기기 때문에 버블 정렬이라고 함.
- 비교 후 스와프까지 하기 때문에 한 passthrough 당 2단계가 걸림.
- 시간 복잡도
    - O(N^2)
        - paththrough 당 2단계 걸리니까
- 공간 복잡도
    - O(1)
- 데이터 크기가 커지면 시간 복잡도에서 비효율적이라서 거의 사용 안 함.
- 구현이 간단하고 거의 정렬된 데이터에 대해 공간 복잡도가 효율적이어야 할 때 사용할 수 있긴 함.
    - e.g., 학생 성적이 대부분 정렬된 상태에서 한두 개의 성적만 바뀐 경우

#### Selection Sort
- 배열의 각 셀을 돌며 셀의 값과 최소값을 비교하며 정렬하는 방식
    - 예를 들어, 시작은 0번째 인덱스부터 하고 최소값 설정도 0번 인덱스의 값부터.
    - 1번 인덱스의 값고 0번째를 비교
    - 1번 인덱스 값이 더 크면 0번 인덱스 값을 최소값으로 유지
    - 0번 인덱스 값이 더 크면 1번 인덱스 값을 최소값으로 변경
    - 위 과정을 반복
- 시간 복잡도
    - 모든 시나리오에서 O(N^2)
- 공간 복잡도
    - O(1)
- 데이터 크기가 커지면 시간 복잡도에서 비효율적

#### Insertion Sort
- 최소값과 현재 배열의 값을 비교한 후, 최소값을 배열에 밀어넣으며 정렬을 하는 방식
    - 시작할 때는 1번 인덱스의 값을 최소값으로 설정한 후 시작
    - 최소값과 모든 배열의 값을 비교함.
    - 만약 현재 배열의 값이 최소값보다 더 크다면, 현재 배열의 위치에 최소값을 넣어줌.
    - 그리고 현재 배열의 값을 최소값 자리로 옮김.
    - 이상을 반복
- 시간 복잡도
    - 최악 : N^2 단계
    - 평균 : N^2 / 2 단계
    - 최선 : N 단계
- 공간 복잡도
    - O(1)
- 이미 정렬된 상태에서 정렬 순서를 유지하면서 실시간으로 데이터를 추가할 때 사용할 수 있긴 함.

#### Quick Sort
- Divide-and-Conquer 방법을 사용하는 대표적인 알고리즘 중 하나
- 구현 방법: 오름차순
    - 분할 단계
        - 배열의 맨 마지막 값을 피벗으로 설정 (이건 맨 앞 또는 랜덤하게 아무거나 선택해도 되나봄.)
        - 피벗 위치는 제외하고 배열의 맨 앞과 맨 뒤 값에 포인터 설정함.
        - 왼쪽 포인터는 피벗보다 큰 수가 나오기 전까지 계속 오른쪽으로 움직여줌.
        - 오른쪽 포인터는 피벗보다 작은 수가 나오기 전까지 계속 왼쪽으로 움직여줌.
        - 포인터 둘 다 멈췄을 때, 두 포인터가 가리키는 값을 서로 바꿔줌.
        - 위 과정을 반복
        - 반복하다가 두 포인터가 같은 값을 가리키거나 포인터가 서로 교차됐을 때 왼쪽 포인터가 가리키는 값과 피벗 값을 바꿔줌.
            - 이러면 피벗을 기준으로 왼쪽 값은 전부 피벗보다 작은 값, 오른쪽 값은 피벗보다 큰 값들로 이루어지게 됨.
        - 왼쪽 포인터가 사실상 피벗값을 가리키게 됐음.
    - 정렬 단계
        - 피벗값을 기준으로 왼쪽 배열에 대해 분할 단계를 재귀적으로 반복함.
        - 피벗값을 기준으로 오른쪽 배열에 대해 분할 단계를 재귀적으로 반복함.
        - 재귀 종료 조건은(기저 조건) 배열의 원소가 1개 이하가 됐을 때임.
- 내림차순 일 땐 왼쪽 <-> 오른쪽 하면 됨.
- 시간 복잡도
    - 최악(이미 정렬된 데이터일 때): O(N^2)
    - 평균 및 최선: O(N log N)
        - 분할하는 횟수가 평균적으로 N * log N 이라서
- 공간 복잡도
    - O(log n)
        - 재귀 호출에 필요한 스택 메모리임.
- 랜덤 데이터, 제자리 정렬(e.g., 연결리스트 정렬), 평균적인 성능이 중요한 경우에 사용함.

#### Merge Sort
- 병합 정렬은 Divide-and-Conquer 방법을 사용하는 대표적인 알고리즘 중 하나
- 리스트를 여러 개의 하위 리스트로 분할한 후, 정렬된 하위 리스트를 병합하여 전체 리스트를 정렬하는 방법
- 구현 방법
    - 배열의 중간 지점을 기준으로 배열을 재귀적으로 분할해줌.
        - 배열의 시작부터 중간 전까지 재귀, 중간부터 배열 끝까지 재귀
        - 기저 조건은 하위 배열의 원소가 1개가 될 때까지
    - 2개로 분할한 배열의 값을 비교 시작
    - 오름차순이라면, 값이 작은 쪽을 먼저 합쳐줌.
- 시간 복잡도
    - 모든 시나리오에서 O(N log N)
- 공간 복잡도
    - 모든 시나리오에서 O(N)
    - 메모리 사용률이 heap sort보다 좋지 못함.
- 제자리 정렬, 파일 병합, 같은 키 값을 가진 데이터의 순서가 바뀌면 안 되는 문제 등에 사용