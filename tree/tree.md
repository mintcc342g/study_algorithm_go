# Tree, Tries

## Contents
- [Tree](#tree)
- [Binary Tree](#binary-tree)
- [Binary Search Tree](#binary-search-tree)
- [Heap](#heap)
- [B-Tree](#b-tree)
- [Trie](#trie)


## Tree

### Basic Concepts
- 한 노드가 여러 노드로의 '링크'를 갖고 있는 형태
- 트리는 부모 노드가 반드시 홀수
- 트리를 만들 땐, 무작위로 정렬된 데이터를 사용해야 균형잡힌 트리가 만들어짐.
    - 부모와 자식 간에 규칙이 있기 때문에, 정렬된 데이터를 사용할 경우 트리 모양으로 안 만들어지기 때문임.
- 용어
    - root node: 최상위 노드
    - parent node: 어떤 노드의 상위 노드
    - child node: 어떤 노드의 하위 노드
    - leaf node(terminal node): child node가 하나도 없는 노드
    - sibling(brother node): 동일한 parent node를 가진 노드
    - level: 트리의 계층(트리의 깊이)
    - depth: 트리의 최대 깊이

### 관련 알고리즘
- 순회; Traversal
    - 헷갈리니까 그림 반드시 볼 것!!
    - 전위 순회; Preorder Traversal
        - 자식 노드보다 현재 노드를 먼저 방문하는 방법
        - 부모 -> 왼쪽 자식 -> 오른쪽 자식 순으로 방문
    - 중위 순회; Inorder Traversal
        - 왼쪽 자식 -> 부모 -> 오른쪽 자식 순으로 방문
    - 후위 순회; Postorder Traversal
        - 모든 자식 노드들을 먼저 방문한 뒤 마지막에 현재 노드를 방문하는 방법
        - 왼쪽 자식 -> 오른쪽 자식 -> 부모 순으로 방문
    - [참고 링크](https://hongku.tistory.com/160)


## Binary Tree

### Basic Concepts
- 각 노드가 0에서 최대 2개의 자식을 갖는 트리
- `child1 < parent < child2` 이어야 함.
    - 한 자식은 부모보다 작은 값을 가져야 함.
    - 다른 하나는 부모보다 큰 값을 가져야 함.
- 자식 없는 노드는 말단 노드라고 부름.
- Big O
    - 트리의 종류에 상관 없이 거의 동일
        - perfect binary tree만 삽입 시 O(n)인데, 트리를 재구성해야 하기 때문임.
    - 공간 복잡도: O(n)
    - 시간 복잡도(탐색, 삽입, 삭제)
        - 평균: O(log n)
        - 최악: O(n)

### 종류
- 완전 이진 트리; complete binary tree
    - 말단 노드의 부모를 제외한 트리의 모든 높이에서 자식을 2개씩 다 갖고 있는 트리
    - 말단 노드의 부모는 2개 안 갖고 있어도 되는데, 자식이 1개인 경우엔 왼쪽부터 채워져 있어야 함.
- 전 이진 트리; full binary tree
    - 모든 노드의 자식이 없거나 정확히 두개 있는 경우를 말함.
    - 즉, 자식이 1개만 있는 노드가 없는 경우임.
- 포화 이진 트리; perfect binary tree
    - 말단 노드를 제외한 모든 노드가 자식을 2개씩 갖고 있는 트리
    - 모든 말단 노드는 같은 높이에 있어야 함.
    - 말단 노드가 위치한 레벨에서 노드의 개수가 최대가 되어야 함.
    - 포화 이진 트리의 노드 개수는 `2^k-1`(k는 트리의 높이)
- 이진 탐색 트리; binary search tree
    - 모든 노드가 특정 순서를 따르는 속성이 있는 이진 트리를 말함.
        - 예를 들어, '현재 노드 하위의 모든 왼쪽 자식들 <= 현재 노드 < 현재 노드 하위의 모든 오른쪽 자식들'을 만족해야 함.
    - 중복값을 허용하지 않음.


## Heap

### Basic Concepts
- complete binary tree의 일종인데, 다음과 같은 조건이 있음.
    - 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(또는 작은) 상태를 유지해야 함.
    - 값이 왼쪽 자식부터 채워져야 함.
- 힙 트리에서는 중복된 값을 허용함.
- 최대값이나 최소값을 빠르게 찾아낼 수 있음.
- 우선순위 큐; Priority Queue를 만들 때 자주 쓰이는 자료구조 (자세한 건 큐 참고)

### heap sort
- 시간복잡도 기준
    - 생성: O(N)
    - 정렬: O(N log N) (평균, 최악 전부 그런 듯)
        - 병합정렬(merge sort)이 같은 시간복잡도를 갖는데, heap sort의 공간 복잡도는 O(1) 이라 메모리를 덜 씀.
        - 정렬할 때, 힙에 원소를 삽입하면서 힙 구조를 만들어나가면서 하기 때문에 N이 더 붙은 것
- k번째 큰 수 찾기, 우선순위 큐 구현, 메모리 제약 있는 대규모 데이터 정렬 등에 사용하기 좋음.

### 종류
- 최대 힙; Max Heap
    - 부모 노드의 값 >= 양쪽 자식 노드의 값
    - 자식 노드 간의 크고 작음은 신경 안 씀.
- 최소 힙; Min Heap
    - 부모 노드의 값 <= 양쪽 자식 노드의 값
    - 자식 노드 간의 크고 작음은 신경 안 씀.

### 구현
- 기본적으로 배열로 구현
- 배열의 뒤 절반은 리프 노드임.
- 배열에서 이진트리 노드 인덱스 찾기
    - 0-based 배열인 경우
        - 왼쪽 자식 노드의 인덱스: `parent_idx * 2 + 1`
        - 오른쪽 자식 노드의 인덱스: `parent_idx * 2 + 2`
        - 부모 노드의 인덱스: `(child_idx - 1) / 2`
    - 1-based 배열인 경우
        - 1-based 배열은 구현을 쉽게 하기 위해 0번 인덱스를 안 씀.
            - `example.go`의 `MinHeap`이 여기에 해당됨.
        - 왼쪽 자식 노드의 인덱스: `parent_idx * 2`
        - 오른쪽 자식 노드의 인덱스: `parent_idx * 2 + 1`
        - 부모 노드의 인덱스: `child_idx/2 `
- heap 만들 때 필요한 메서드
    - `down_heap`
        - 루트 노드의 값을 자식 노드와 비교하면서 그 값이 맞는 자리를 찾을 때까지 그 값을 계속 내림. (root -> leaf)
        - heap 에서 요소를 삭제(Pop)할 때 사용함.
        - 이 메서드의 시간 복잡도는 O(log N)
        - 알고리즘 문제에서는 이 메서드만 사용하는 경우가 있음. (heapify 라는 이름으로..)
            - 입력된 모든 데이터를 확인해야 하는 경우
            - 주어진 배열을 한 번에 힙으로 변환해서 사용해야 한다든지.
            - 이미 정렬되어 온 데이터로 힙을 구성한 후 k번째로 작은/큰 값 찾아야 한다든지
            - 특히 입력된 데이터의 크기가 작을 때 괜찮음.
            - 예를 들어, 모든 조합을 평가한 후에 k개를 추출한다든지
     - `up_heap`
        - 새 값을 가장 마지막 자식 노드에 넣고, 부모와 비교하면서 자리를 찾을 때 까지 그 값을 위로 올림. (leaf -> root)
        - heap에 요소를 삽입(Push)할 때 사용함.
        - 이 메서드의 시간 복잡도는 O(log N)
        - 대부분의 heap 문제에서 `down_heap`이랑 함께 사용됨.
            - 이거 같이 쓰면 heap을 일정 크기로 유지할 수 있고, 전체 데이터를 순회하지 않아도 됨.
            - 그래서 입력 데이터가 클 때 `down_heap`만 사용하는 것보다 훨씬 효율적임.
            - 예를 들어, 최소 k개의 데이터만 찾기 위해 힙 크기를 k개로 유지하면서 작업할 때
- golang 에서는 `container/heap` 를 이용할 수 있음.
    - 이거 쓸 때 heap 은 배열로 구성해줘야 하고, `Len()`, `Less()`, `Swap()`, `Empty()`, `Push()`, `Pop()` 구현해줘야 함.

### 참고
- [[자료구조] 힙(heap이란)](https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html)
- LeetCode


## B-Tree

- 이진 트리의 일종
- 트리 내의 데이터의 삽입/삭제가 발생해도 그 균형을 최대한 유지함.
   - 다른 트리 구조에 비해서 삽입/삭제 시에 균형을 유지하도록 설계되었기 때문
   - 비슷하게 Balanced Binary Search Tree 종류가 자동으로 균형을 유지한다는 듯(e.g., AVL, Red-Black 등)
- 이거 업글 버전인 B+ 트리가 RDB의 자료구조로 많이 쓰임.
- 주요 특징
    - 노드 내에 데이터를 여러 개 가질 수 있음.
    - 어느 부모 노드의 데이터가 N개일 때 자식 노드의 데이터 개수는 N+1 임.
    - +1 이 되는 이유는 삽입 과정에서 발생하는 노드 분열 때문인 듯
        - 3차 B 트리, 홀수 차수인 경우 예시를 봐보자.
        - 부모 노드는 2개의 데이터 자리가 있을 것
        - 거기에 데이터가 꽉 차있는 상태인데, 새로운 데이터를 넣는다 치자.
        - 부모 노드를 분열을 시키고, 부모 노드의 데이터들과 새로 넣으려고 하는 데이터를 비교
        - 그 중 중간값을 부모 노드 자리에 넣고, 나머지 값들은 새로운 자식 노드를 만들어서 거기에 데이터를 넣어줌.
        - 근데 만약 새로 만든 노드에 빈 공간이 하나 뿐이라면, 분열시킨 데이터들이 자리를 다 차지하고 들어가서 이후에 새로운 데이터를 또 받을 수 없게 됨.
        - 그래서 새롭게 만든 노드들한테 +1개의 빈 공간을 주는 것
- 용어
    - N차 트리
        - 자식 노드의 데이터를 N개 갖는 트리를 일컫는 것
        - 예를 들어, 부모가 3개라면 자식 노드는 4개가 될텐데, 이 경우 4차 B 트리라고 말함.
- 참고문제
    - LeetCode '1382. Balance a Binary Search Tree'
        - inorder traversal로 트리를 탐색해서 값들을 배열에 차례로 넣고,
        - 배열 중간값을 노드값으로, 배열 중간의 왼쪽 값들은 Left 노드로, 오른쪽 값들은 Right 노드로 넣음.
        - inorder 를 사용하는 이유는 부모값이 중간에 위치하게 해주기 때문이라는 듯
- 참고
    - [[자료구조] B 트리](https://mommoo.tistory.com/108)


## Trie
- n차 트리(n-ary tree)의 변종으로, 각 노드에 문자를 저장하는 자료구조
  - 트리를 아래쪽으로 순회하면 단어가 하나 나옴.
  - 즉, 사전같은 느낌.
- prefix tree 라고도 불림.
- 유효한 단어 집합을 이용하는 문제에서 많이 쓰임.