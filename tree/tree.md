# Tree, Tries

## Contents
- [Tree](#tree)
- [Binary Tree](#binary-tree)
- [Binary Search Tree](#binary-search-tree)
- [B-Tree](#b-tree)

## Tree

### Basic Concepts
- 한 노드가 여러 노드로의 '링크'를 갖고 있는 형태
- 트리는 부모 노드가 반드시 홀수
- 트리를 만들 땐, 무작위로 정렬된 데이터를 사용해야 균형잡힌 트리가 만들어짐.
    - 부모와 자식 간에 규칙이 있기 때문에, 정렬된 데이터를 사용할 경우 트리 모양으로 안 만들어지기 때문임.
- 검색/삽입/삭제 효율은 보통 O(log N) 인데, 불균형이 심한 트리의 경우엔 O(N)
- 용어
    - `루트`: 최상위 노드
    - `부모`: 어떤 노드의 상위 노드
    - `자식`: 어떤 노드의 하위 노드
    - `레벨`: 트리의 계층

### 관련 알고리즘

- 순회; Traversal
    - 헷갈리니까 그림 반드시 볼 것!!
    - 전위 순회; Preorder Traversal
        - 자식 노드보다 현재 노드를 먼저 방문하는 방법
        - 부모 -> 왼쪽 자식 -> 오른쪽 자식 순으로 방문
    - 중위 순회; Inorder Traversal
        - 왼쪽 자식 -> 부모 -> 오른쪽 자식 순으로 방문
    - 후위 순회; Postorder Traversal
        - 모든 자식 노드들을 먼저 방문한 뒤 마지막에 현재 노드를 방문하는 방법
        - 왼쪽 자식 -> 오른쪽 자식 -> 부모 순으로 방문
    - [참고 링크](https://hongku.tistory.com/160)
- heap에도 쓰이니까 힙도 참고할 것


## Binary Tree

### Basic Concepts
- 각 노드가 0에서 최대 2개의 자식을 갖는 트리
- 한 노드에 자식이 2개 있을 경우
    - 한 자식은 부모 보다 작은 값을 가져야 함.
    - 다른 하나는 부모보다 큰 값을 가져야 함.
- 이진 트리는 left < parent < right 이어야 한다는 듯
- 자식 없는 노드는 말단 노드라고 부름.
- 종류
  - 완전 이진 트리
    - 트리의 모든 높이에서 자식을 2개씩 다 갖고 있는 트리
    - 말단 노드는 2개 안 갖고 있어도 되는데, 자식이 1개인 경우엔 왼쪽부터 채워져 있어야 함.
  - 전 이진 트리; full binary tree
    - 모든 노드의 자식이 없거나 정확히 두개 있는 경우를 말함.
    - 즉, 자식이 1개만 있는 노드가 없는 경우임.
  - 포화 이진 트리; perfect binary tree
    - 말단 노드를 제외한 모든 노드가 자식을 2개씩 갖고 있는 트리
    - 모든 말단 노드는 같은 높이에 있어야 함.
    - 말단 노드가 위치한 레벨에서 노드의 개수가 최대가 되어야 함.
    - 포화 이진 트리의 노드 개수는 `2^k-1`(k는 트리의 높이)


## Binary Search Tree

### Basic Concepts
- 이진 탐색 트리는 모든 노드가 특정 순서를 따르는 속성이 있는 이진 트리를 말함.
- 예를 들어, '현재 노드 하위의 모든 왼쪽 자식들 <= 현재 노드 < 현재 노드 하위의 모든 오른쪽 자식들'을 만족해야 함.


## B-Tree

- 이진 트리의 일종
- 트리 내의 데이터의 삽입/삭제가 발생해도 그 균형을 최대한 유지함.
   - 균형이 잘 잡힌 이진 트리는 삽입/삭제/검색 효율이 O(log N) 으로 좋으니까 유지하려고 하는 것
- 이거 업글 버전인 B+ 트리가 RDB의 자료구조로 많이 쓰인다고 함.
- 주요 특징
    - 노드 내에 데이터를 여러 개 가질 수 있음.
    - 어느 부모 노드의 데이터가 N개일 때 자식 노드의 데이터 개수는 N+1 임.
    - +1 이 되는 이유는 삽입 과정에서 발생하는 노드 분열 때문인 듯
        - 3차 B 트리, 홀수 차수인 경우 예시를 봐보자.
        - 부모 노드는 2개의 데이터 자리가 있을 것
        - 거기에 데이터가 꽉 차있는 상태인데, 새로운 데이터를 넣는다 치자.
        - 부모 노드를 분열을 시키고, 부모 노드의 데이터들과 새로 넣으려고 하는 데이터를 비교
        - 그 중 중간값을 부모 노드 자리에 넣고, 나머지 값들은 새로운 자식 노드를 만들어서 거기에 데이터를 넣어줌.
        - 근데 만약 새로 만든 노드에 빈 공간이 하나 뿐이라면, 분열시킨 데이터들이 자리를 다 차지하고 들어가서 이후에 새로운 데이터를 또 받을 수 없게 됨.
        - 그래서 새롭게 만든 노드들한테 +1개의 빈 공간을 주는 것
- 용어
    - N차 트리
        - 자식 노드의 데이터를 N개 갖는 트리를 일컫는 것
        - 예를 들어, 부모가 3개라면 자식 노드는 4개가 될텐데, 이 경우 4차 B 트리라고 말함.
- 참고문제
    - LeetCode '1382. Balance a Binary Search Tree'
        - inorder traversal로 트리를 탐색해서 값들을 배열에 차례로 넣고,
        - 배열 중간값을 노드값으로, 배열 중간의 왼쪽 값들은 Left 노드로, 오른쪽 값들은 Right 노드로 넣음.
        - inorder 를 사용하는 이유는 부모값이 중간에 위치하게 해주기 때문이라는 듯
- 참고
    - [[자료구조] B 트리](https://mommoo.tistory.com/108)

## Trie
- n차 트리(n-ary tree)의 변종으로, 각 노드에 문자를 저장하는 자료구조
  - 트리를 아래쪽으로 순회하면 단어가 하나 나옴.
  - 즉, 사전같은 느낌.
- prefix tree 라고도 불림.
- 유효한 단어 집합을 이용하는 문제에서 많이 쓰임.